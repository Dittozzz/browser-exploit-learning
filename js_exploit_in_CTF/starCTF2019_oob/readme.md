oob.diff 给数组增加了一个新的方法`oob`，我也不清楚v8 builtin函数的机制，就一点一点看了下代码.从初学者的角度分析下源码.

#### patch分析:

首先在`bootstrapper.cc`增加了以下代码:
```c++
--- a/src/bootstrapper.cc
+++ b/src/bootstrapper.cc
@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
                           Builtins::kArrayPrototypeCopyWithin, 2, false);
     SimpleInstallFunction(isolate_, proto, "fill",
                           Builtins::kArrayPrototypeFill, 1, false);
+    SimpleInstallFunction(isolate_, proto, "oob",
+                          Builtins::kArrayOob,2,false);
     SimpleInstallFunction(isolate_, proto, "find",
                           Builtins::kArrayPrototypeFind, 1, false);
     SimpleInstallFunction(isolate_, proto, "findIndex",
```
看下`SimpleInstallFunction`的实现:
```c++
V8_NOINLINE Handle<JSFunction> SimpleInstallFunction(
    Isolate* isolate, Handle<JSObject> base, const char* name, //name = "oob"
    Builtins::Name call, int len, bool adapt,
    PropertyAttributes attrs = DONT_ENUM) {
  // Although function name does not have to be internalized the property name
  // will be internalized during property addition anyway, so do it here now.
  Handle<String> internalized_name =
      isolate->factory()->InternalizeUtf8String(name); 
  Handle<JSFunction> fun =
      SimpleCreateFunction(isolate, internalized_name, call, len, adapt);
  JSObject::AddProperty(isolate, base, internalized_name, fun, attrs);
  return fun;
}
```
参数`call`为实现的builtin函数.

看到这里可以猜测是给Array增加了原生属性，其key为`internalized_name`,value为`fun`,即给Array加入原生方法oob.
```
JSObject::AddProperty(isolate, base, internalized_name, fun, attrs);
```


然后patch了`builtins-array.cc`,给出了oob方法的具体实现:
```c++
--- a/src/builtins/builtins-array.cc
+++ b/src/builtins/builtins-array.cc
@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,
   return *final_length;
 }
 }  // namespace
+BUILTIN(ArrayOob){
+    uint32_t len = args.length();
+    if(len > 2) return ReadOnlyRoots(isolate).undefined_value();
+    Handle<JSReceiver> receiver;
+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
+            isolate, receiver, Object::ToObject(isolate, args.receiver()));
+    Handle<JSArray> array = Handle<JSArray>::cast(receiver);
+    FixedDoubleArray elements = FixedDoubleArray::cast(array->elements());
+    uint32_t length = static_cast<uint32_t>(array->length()->Number());
+    if(len == 1){
+        //read
+        return *(isolate->factory()->NewNumber(elements.get_scalar(length)));
+    }else{
+        //write
+        Handle<Object> value;
+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
+                isolate, value, Object::ToNumber(isolate, args.at<Object>(1)));
+        elements.set(length,value->Number());
+        return ReadOnlyRoots(isolate).undefined_value();
+    }
+}
```

先看下BUILTIN这个宏:
```c++
// ----------------------------------------------------------------------------
// Support macro for defining builtins in C++.
// ----------------------------------------------------------------------------
//
// A builtin function is defined by writing:
//
//   BUILTIN(name) {
//     ...
//   }
//
// In the body of the builtin function the arguments can be accessed
// through the BuiltinArguments object args.
// TODO(cbruni): add global flag to check whether any tracing events have been
// enabled.
#define BUILTIN(name)                                                        \
  V8_WARN_UNUSED_RESULT static Object Builtin_Impl_##name(                   \
      BuiltinArguments args, Isolate* isolate);                              \
                                                                             \
  V8_NOINLINE static Address Builtin_Impl_Stats_##name(                      \
      int args_length, Address* args_object, Isolate* isolate) {             \
    BuiltinArguments args(args_length, args_object);                         \
    RuntimeCallTimerScope timer(isolate,                                     \
                                RuntimeCallCounterId::kBuiltin_##name);      \
    TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("v8.runtime"),                    \
                 "V8.Builtin_" #name);                                       \
    return Builtin_Impl_##name(args, isolate)->ptr();                        \
  }                                                                          \
                                                                             \
  V8_WARN_UNUSED_RESULT Address Builtin_##name(                              \
      int args_length, Address* args_object, Isolate* isolate) {             \
    DCHECK(isolate->context().is_null() || isolate->context()->IsContext()); \
    if (V8_UNLIKELY(TracingFlags::is_runtime_stats_enabled())) {             \
      return Builtin_Impl_Stats_##name(args_length, args_object, isolate);   \
    }                                                                        \
    BuiltinArguments args(args_length, args_object);                         \
    return Builtin_Impl_##name(args, isolate)->ptr();                        \
  }                                                                          \
                                                                             \
  V8_WARN_UNUSED_RESULT static Object Builtin_Impl_##name(                   \
      BuiltinArguments args, Isolate* isolate)
```
通过注释可以得知 builtin函数通过BuiltinArguments类型的对象args来获取参数.

宏的最开始部分是实现的builtin函数的声明，为了后面两个函数可以使用。真正实现的函数的名字是`Builtin_Impl_##name`，宏中的##起连接作用，对应到ArrayOob，即是Builtin_Impl_ArrayOob，可以看到传入的参数有 `BuiltinArguments args, Isolate* isolate`

下面分析下这个函数:
```c++
+BUILTIN(ArrayOob){
+    uint32_t len = args.length();
+    if(len > 2) return ReadOnlyRoots(isolate).undefined_value();
+    Handle<JSReceiver> receiver;
+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
+            isolate, receiver, Object::ToObject(isolate, args.receiver()));
+    Handle<JSArray> array = Handle<JSArray>::cast(receiver);
+    FixedDoubleArray elements = FixedDoubleArray::cast(array->elements());
+    uint32_t length = static_cast<uint32_t>(array->length()->Number());
+    if(len == 1){
+        //read
+        return *(isolate->factory()->NewNumber(elements.get_scalar(length)));
+    }else{
+        //write
+        Handle<Object> value;
+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
+                isolate, value, Object::ToNumber(isolate, args.at<Object>(1)));
+        elements.set(length,value->Number());
+        return ReadOnlyRoots(isolate).undefined_value();
+    }
```




