阅读这里的源码可以得知如何进行reduce的

#### Reducer类
```c++
// reducer可以基于其operator和input来减少或简化给定Node。 reducer类用作graph reducer的扩展点，
// 用于特定于语言的缩减（例如，基于类型的缩小或低级操作符的常量折叠）可以集成到图缩减阶段中。
class V8_EXPORT_PRIVATE Reducer {
 public:
  virtual ~Reducer() = default;

  // Only used for tracing, when using the --trace_turbo_reduction flag.
  virtual const char* reducer_name() const = 0;

  // Try to reduce a node if possible.
  virtual Reduction Reduce(Node* node) = 0;

  // Invoked by the {GraphReducer} when all nodes are done.  Can be used to
  // do additional reductions at the end, which in turn can cause a new round
  // of reductions.
  virtual void Finalize();

  // Helper functions for subclasses to produce reductions for a node.
  static Reduction NoChange() { return Reduction(); }
  static Reduction Replace(Node* node) { return Reduction(node); }
  static Reduction Changed(Node* node) { return Reduction(node); }
};
```
Reducer类中的关键成员函数都是虚函数，需要子类来完成其功能，后面的一些reduce类都是Reducer的子类，他们完善了Reduce函数。


#### GraphReducer类

```
// Performs an iterative reduction of a node graph.
class V8_EXPORT_PRIVATE GraphReducer
    : public NON_EXPORTED_BASE(AdvancedReducer::Editor) {
 public:
  GraphReducer(Zone* zone, Graph* graph, Node* dead = nullptr);
  ~GraphReducer() override;

  Graph* graph() const { return graph_; }

  void AddReducer(Reducer* reducer);

  // Reduce a single node.
  void ReduceNode(Node* const);
  // Reduce the whole graph.
  void ReduceGraph();

 private:
  enum class State : uint8_t;
  struct NodeState {
    Node* node;
    int input_index;
  };

  // Reduce a single node.
  Reduction Reduce(Node* const);
  // Reduce the node on top of the stack.
  void ReduceTop();

  // Replace {node} with {replacement}.
  void Replace(Node* node, Node* replacement) final;

  // Replace value uses of {node} with {value} and effect uses of {node} with
  // {effect}. If {effect == nullptr}, then use the effect input to {node}. All
  // control uses will be relaxed assuming {node} cannot throw.
  void ReplaceWithValue(Node* node, Node* value, Node* effect,
                        Node* control) final;

  // Replace all uses of {node} with {replacement} if the id of {replacement} is
  // less than or equal to {max_id}. Otherwise, replace all uses of {node} whose
  // id is less than or equal to {max_id} with the {replacement}.
  void Replace(Node* node, Node* replacement, NodeId max_id);

  // Node stack operations.
  void Pop();
  void Push(Node* node);

  // Revisit queue operations.
  bool Recurse(Node* node);
  void Revisit(Node* node) final;

  Graph* const graph_;
  Node* const dead_;
  NodeMarker<State> state_;
  ZoneVector<Reducer*> reducers_;
  ZoneQueue<Node*> revisit_;
  ZoneStack<NodeState> stack_;//NodeState这个结构体保存了Node和idx
};
enum class GraphReducer::State : uint8_t {
  kUnvisited,
  kRevisit,
  kOnStack,
  kVisited
};
struct NodeState {
    Node* node;
    int input_index;
  };
```

看下GraphReducer类，这个类是来完成graph的简化工作的，他将上面Reducer类的子类的实例添加到Vector容器中:
```c++
ZoneVector<Reducer*> reducers_;
void GraphReducer::AddReducer(Reducer* reducer) {
  reducers_.push_back(reducer);
}
```
当遍历graph遇到每个node时，遍历Vector容器，使用每个reducer类的reduce方法来对node进行减少.
```c++
/*遍历graph的时候是从graph的下面(End节点)向上遍历的*/
void GraphReducer::ReduceGraph() { ReduceNode(graph()->end()); }

void GraphReducer::ReduceNode(Node* node) {
  Push(node);//将node push 到 stack_中
  for (;;) {
    if (!stack_.empty()) {
      ReduceTop();
    } else if (!revisit_.empty()) {
      // If the stack becomes empty, revisit any nodes in the revisit queue.
      Node* const node = revisit_.front();
      revisit_.pop();
      if (state_.Get(node) == State::kRevisit) {
        // state can change while in queue.
        Push(node);
      }
    } else {
      // Run all finalizers.
      for (Reducer* const reducer : reducers_) reducer->Finalize();

      // Check if we have new nodes to revisit.
      if (revisit_.empty()) break;
    }
  }//for (;;)
}
```
ReduceTop使用了GraphReducer::Reduce函数中:
```c++
void GraphReducer::ReduceTop() {
  NodeState& entry = stack_.top();
  Node* node = entry.node;//获取stack_顶部的node

  /*如果栈顶的这个节点是死节点(即该节点没有input)，则直接将其pop掉，函数返回*/
  if (node->IsDead()) return Pop();  // Node was killed while on stack.

  Node::Inputs node_inputs = node->inputs();//以该node的input_location和input_count初始化Node::Inputs
    ...
  // All inputs should be visited or on stack. Apply reductions to node.
  Reduction reduction = Reduce(node);//遍历所有的reducer对节点进行reduce

  // If there was no reduction, pop {node} and continue.
  if (!reduction.Changed()) return Pop();

   ...
}
```
GraphReducer::Reduce这里开始遍历
```c++
Reduction GraphReducer::Reduce(Node* const node) {
  auto skip = reducers_.end();
  /* 遍历reducer，让每一个reducer都对该node进行作用*/
  for (auto i = reducers_.begin(); i != reducers_.end();) {
    if (i != skip) { 
      Reduction reduction = (*i)->Reduce(node);
      if (!reduction.Changed()) {
        // No change from this reducer.
      } else if (reduction.replacement() == node) {
        if (FLAG_trace_turbo_reduction) {
          StdoutStream{} << "- In-place update of " << *node << " by reducer "
                         << (*i)->reducer_name() << std::endl;
        }
        skip = i;
        i = reducers_.begin();
        continue;
      } else {
        // {node} was replaced by another node.
        ...
        return reduction;
      }
    }
    ++i;
  }
  if (skip == reducers_.end()) {
    // No change from any reducer.
    return Reducer::NoChange();
  }
  // At least one reducer did some in-place reduction.
  return Reducer::Changed(node);
}
```
