BytecodeGraphBuilder类生成新node使用的函数MakeNode:

```c++
Node* BytecodeGraphBuilder::MakeNode(const Operator* op, int value_input_count,
                                     Node* const* value_inputs,
                                     bool incomplete) {

  /*来获取operator对应的一些属性信息，以便后面确定input的个数*/
  bool has_context = OperatorProperties::HasContextInput(op);
  bool has_frame_state = OperatorProperties::HasFrameStateInput(op);
  bool has_control = op->ControlInputCount() == 1;
  bool has_effect = op->EffectInputCount() == 1;

  Node* result = nullptr;
  if (!has_context && !has_frame_state && !has_control && !has_effect) {
    /*以上属性都没有，则直接Graph::NewNode*/
    result = graph()->NewNode(op, value_input_count, value_inputs, incomplete);
  } else {
    bool inside_handler = !exception_handlers_.empty();
    /* input的个数的基数是value_input_count,
     * 在它的数量上加上 context，frame_state_control,effect节点的个数
     */

    int input_count_with_deps = value_input_count;
    if (has_context) ++input_count_with_deps;
    if (has_frame_state) ++input_count_with_deps;
    if (has_control) ++input_count_with_deps;
    if (has_effect) ++input_count_with_deps;
    /*确定input指针数组的空间*/
    Node** buffer = EnsureInputBufferSize(input_count_with_deps);
    if (value_input_count > 0) {
      //将value_inputs_node_ptr复制过来
      memcpy(buffer, value_inputs, kSystemPointerSize * value_input_count);
    }
    /*前面存放的是value_input_node_ptr , 后面才是多出来的用来存放其他input_ptr的空间*/
    Node** current_input = buffer + value_input_count;
    if (has_context) {
      /*增加 context_node_ptr*/
      *current_input++ = OperatorProperties::NeedsExactContext(op)
                             ? environment()->Context()
                             : jsgraph()->HeapConstant(native_context());
    }
    if (has_frame_state) {
      // frame_state将在稍后插入。这里使用{Dead}节点填充下，
      // 稍后通过在各个访问者方法中调用{PrepareFrameState}来覆盖真实的frame_state。
      *current_input++ = jsgraph()->Dead();
    }
    if (has_effect) {
      *current_input++ = environment()->GetEffectDependency();
    }
    if (has_control) {
      *current_input++ = environment()->GetControlDependency();
    }
    /* 以Buffer指向的Node指针数组作为input_ptr数组来New一个新的Node*/
    result = graph()->NewNode(op, input_count_with_deps, buffer, incomplete);
    // Update the current control dependency for control-producing nodes.
    if (result->op()->ControlOutputCount() > 0) {
      environment()->UpdateControlDependency(result);
    }
    // Update the current effect dependency for effect-producing nodes.
    if (result->op()->EffectOutputCount() > 0) {
      environment()->UpdateEffectDependency(result);
    }
    // Add implicit exception continuation for throwing nodes.
    if (!result->op()->HasProperty(Operator::kNoThrow) && inside_handler) {
      int handler_offset = exception_handlers_.top().handler_offset_;
      int context_index = exception_handlers_.top().context_register_;
      interpreter::Register context_register(context_index);
      Environment* success_env = environment()->Copy();
      const Operator* op = common()->IfException();
      Node* effect = environment()->GetEffectDependency();
      Node* on_exception = graph()->NewNode(op, effect, result);
      Node* context = environment()->LookupRegister(context_register);
      environment()->UpdateControlDependency(on_exception);
      environment()->UpdateEffectDependency(on_exception);
      environment()->BindAccumulator(on_exception);
      environment()->SetContext(context);
      MergeIntoSuccessorEnvironment(handler_offset);
      set_environment(success_env);
    }
    // Add implicit success continuation for throwing nodes.
    if (!result->op()->HasProperty(Operator::kNoThrow) && inside_handler) {
      const Operator* if_success = common()->IfSuccess();
      Node* on_success = graph()->NewNode(if_success, result);
      environment()->UpdateControlDependency(on_success);
    }
    // Ensure checkpoints are created after operations with side-effects.
    if (has_effect && !result->op()->HasProperty(Operator::kNoWrite)) {
      mark_as_needing_eager_checkpoint(true);
    }
  }

  return result;
}
}
```

总结下：首先确定该operator是否有context，frame_state,control,effect节点
```c++
  bool has_context = OperatorProperties::HasContextInput(op);
  bool has_frame_state = OperatorProperties::HasFrameStateInput(op);
  bool has_control = op->ControlInputCount() == 1;
  bool has_effect = op->EffectInputCount() == 1;
```
如果都没有则直接调用Graph:NewNode,只要有其中的一项，就会重新确定input指针数组的空间：
```
  Node* result = nullptr;
  if (!has_context && !has_frame_state && !has_control && !has_effect) {
    /*以上属性都没有，则直接Graph::NewNode*/
    result = graph()->NewNode(op, value_input_count, value_inputs, incomplete);
  } else {
    bool inside_handler = !exception_handlers_.empty();
    /* input的个数的基数是value_input_count,
     * 在它的数量上加上 context，frame_state_control,effect节点的个数
     */

    int input_count_with_deps = value_input_count;
    if (has_context) ++input_count_with_deps;
    if (has_frame_state) ++input_count_with_deps;
    if (has_control) ++input_count_with_deps;
    if (has_effect) ++input_count_with_deps;
    /*确定input指针数组的空间*/
    Node** buffer = EnsureInputBufferSize(input_count_with_deps);
```
然后将value_input_node_ptr复制过来:
```
    if (value_input_count > 0) {
      //将value_inputs_node_ptr复制过来
      memcpy(buffer, value_inputs, kSystemPointerSize * value_input_count);
    }
```
然后进行一系列的input_ptr赋值操作...


创建graph的函数:
```c++
void BytecodeGraphBuilder::CreateGraph() {
  BytecodeArrayRef bytecode_array_ref(broker(), bytecode_array());

  SourcePositionTable::Scope pos_scope(source_positions_, start_position_);

  // 设置图的基本结构。 {Start}的output是形式参数（包括接收器）加上新目标，参数数量，上下文和闭包。
  int actual_parameter_count = bytecode_array_ref.parameter_count() + 4;
  /*graph_成员记录了graph的开始节点和结束节点*/
  graph()->SetStart(graph()->NewNode(common()->Start(actual_parameter_count)));

  Environment env(
      this, bytecode_array_ref.register_count(),
      bytecode_array_ref.parameter_count(),
      bytecode_array_ref.incoming_new_target_or_generator_register(),
      graph()->start());
  set_environment(&env);

  VisitBytecodes();//真正创建graph的函数，访问bytecodeArray，然后生成graph

  // Finish the basic structure of the graph.
  int const input_count = static_cast<int>(exit_controls_.size());
  Node** const inputs = &exit_controls_.front();
  Node* end = graph()->NewNode(common()->End(input_count), input_count, inputs);
  graph()->SetEnd(end);//记录End节点
}
```
