Node大概如下：
```c++
class Node
{
	public:
		class InputEdges;
		class Inputs;
		class UseEdges;
		class  Uses;
	private:
		struct Use;
		struct OutOfLineInputs; // 当输入数量溢出内联分配空间的容量时的 输入的外部存储
		
		/*头插法，first_use__指向头*/
		void AppendUse(Use* use);
		void RemoveUse(Use* use);
		
		const Operator* op_;
		Type type_;
		Mark mark_;
		uint32_t bit_field_;
		Use* first_use_;
	
}

```

内存布局：
```
//============================================================================
  //== Memory layout ===========================================================
  //============================================================================
  // 节省graph的空间非常重要。 我们使用内存布局技巧，以节省空间的方式将{Node}对象映射到{Use}对象，反之亦然。
  //
  // {Use} links are laid out in memory directly before a {Node}, followed by
  // direct pointers to input {Nodes}.
  //
  // inline case:
  // |Use #N  |Use #N-1|...|Use #1  |Use #0  |Node xxxx |I#0|I#1|...|I#N-1|I#N|
  //          ^                              ^                  ^
  //          + Use                          + Node             + Input
  //
  // 由于每个{Use}实例都记录了它的{input_index}，因此指针算法可以计算{Node}。
  //
  // out-of-line case:
  //     |Node xxxx |
  //     ^       + outline ------------------+
  //     +----------------------------------------+
  //                                         |    |
  //                                         v    | node
  // |Use #N  |Use #N-1|...|Use #1  |Use #0  |OOL xxxxx |I#0|I#1|...|I#N-1|I#N|
  //          ^                                                 ^
  //          + Use                                             + Input
  //
  // Out-of-line storage of input lists is needed if appending an input to
  // a node exceeds the maximum inline capacity.
  // 如果向Node附加input超过最大inline容量，则需要input list的外部存储。
```
