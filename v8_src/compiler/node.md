Node大概如下：
```c++
class Node
{
	public:
		class InputEdges;
		class Inputs;
		class UseEdges;
		class  Uses;
	private:
		struct Use;
		struct OutOfLineInputs; // 当输入数量溢出内联分配空间的容量时的 输入的外部存储
		
		/*头插法，first_use__指向头*/
		void AppendUse(Use* use);
		void RemoveUse(Use* use);
		
		const Operator* op_;
		Type type_;
		Mark mark_;
		uint32_t bit_field_;
		Use* first_use_;
	
}

```

内存布局：
```c++
  //============================================================================
  //== Memory layout ===========================================================
  //============================================================================
  // 节省graph的空间非常重要。 我们使用内存布局技巧，以节省空间的方式将{Node}对象映射到{Use}对象，反之亦然。
  //
  // {Use} links are laid out in memory directly before a {Node}, followed by
  // direct pointers to input {Nodes}.
  //
  // inline case:
  // |Use #N  |Use #N-1|...|Use #1  |Use #0  |Node xxxx |I#0|I#1|...|I#N-1|I#N|
  //          ^                              ^                  ^
  //          + Use                          + Node             + Input
  //
  // 由于每个{Use}实例都记录了它的{input_index}，因此指针算法可以计算{Node}。
  //
  // out-of-line case:
  //     |Node xxxx |
  //     ^       + outline ------------------+
  //     +----------------------------------------+
  //                                         |    |
  //                                         v    | node
  // |Use #N  |Use #N-1|...|Use #1  |Use #0  |OOL xxxxx |I#0|I#1|...|I#N-1|I#N|
  //          ^                                                 ^
  //          + Use                                             + Input
  //
  // Out-of-line storage of input lists is needed if appending an input to
  // a node exceeds the maximum inline capacity.
  // 如果向Node附加input超过最大inline容量，则需要input list的外部存储。
```

input开始的位置是在node实例的后面(高地址处):
```c++
Address Node::inputs_location() const {
return reinterpret_cast<Address>(this) + sizeof(Node);
}
```

为某个node增加input:
```c++
void Node::AppendInput(Zone* zone, Node* new_to) {
	DCHECK_NOT_NULL(zone);
	DCHECK_NOT_NULL(new_to);
	int inline_count = InlineCountField::decode(bit_field_);
	int inline_capacity = InlineCapacityField::decode(bit_field_);
	if (inline_count < inline_capacity) {
		// Append inline input.
		bit_field_ = InlineCountField::update(bit_field_, inline_count + 1);
		*GetInputPtr(inline_count) = new_to; //最新的位置赋值一个node(新增加的input)
		Use* use = GetUsePtr(inline_count);
		use->bit_field_ = Use::InputIndexField::encode(inline_count) |
		Use::InlineField::encode(true);
		new_to->AppendUse(use);//将被新加input的node的对应的use 添加到新添加的input(node)的use链表中
	
	} else {
		// Append out-of-line input.
			…
	}
	Verify();
}
```
将被新加input的node的对应的use 添加到新添加的input(node)的use链表中的AppendUse函数:
```c++
void Node::AppendUse(Use* use) {
	DCHECK(first_use_ == nullptr || first_use_->prev == nullptr);
	DCHECK_EQ(this, *use->input_ptr());
	use->next = first_use_;
	use->prev = nullptr;
	if (first_use_) first_use_->prev = use;
	first_use_ = use;
}
```
