graph 类:

```c++
class V8_EXPORT_PRIVATE Graph final : public NON_EXPORTED_BASE(ZoneObject) {
 public:
  explicit Graph(Zone* zone);

  //创建内联子图时使用的scope。 自动保留图形的原始开始和结束节点，并在离开scope时重置它们。
  class SubgraphScope final {
   public:
    explicit SubgraphScope(Graph* graph)
        : graph_(graph), start_(graph->start()), end_(graph->end()) {}
    ~SubgraphScope() {
      graph_->SetStart(start_);
      graph_->SetEnd(end_);
    }
   private:
    Graph* const graph_;
    Node* const start_;
    Node* const end_;
  };

  // 使用Noded::New来生成一个新的node
  Node* NewNodeUnchecked(const Operator* op, int input_count,
                         Node* const* inputs, bool incomplete = false);
  Node* NewNode(const Operator* op, int input_count, Node* const* inputs,
                bool incomplete = false);

  // Factory template for nodes with static input counts.
  template <typename... Nodes>
  Node* NewNode(const Operator* op, Nodes*... nodes) {
    std::array<Node*, sizeof...(nodes)> nodes_arr{{nodes...}};
    return NewNode(op, nodes_arr.size(), nodes_arr.data());
  }

  // Clone the {node}, and assign a new node id to the copy.
  // 使用Node::Clone
  Node* CloneNode(const Node* node);
  void SetStart(Node* start) { start_ = start; }
  void SetEnd(Node* end) { end_ = end; }

  size_t NodeCount() const { return next_node_id_; }

  void Decorate(Node* node); //装饰
  void AddDecorator(GraphDecorator* decorator); //增加装饰
  void RemoveDecorator(GraphDecorator* decorator);

 private:
  inline NodeId NextNodeId();
  Zone* const zone_;
  Node* start_;
  Node* end_;
  Mark mark_max_;
  NodeId next_node_id_;
  ZoneVector<GraphDecorator*> decorators_;
};//graph
```
Node这里主要记录了开始节点和结束节点，以及装饰器.同时包装了Node::New。
注意下Node::New的参数。参数op是该node对应的operator,input_count是作为新生产的Node的input node的个数，inputs指向的是input node指针数组
后面的MachineGraph类成员中有Graph类型的graph_,使用该成员来生成新的Node.

MachineGraph类的实现:
```c++
class V8_EXPORT_PRIVATE MachineGraph : public NON_EXPORTED_BASE(ZoneObject) {
 public:
  MachineGraph(Graph* graph, CommonOperatorBuilder* common,
               MachineOperatorBuilder* machine)
      : graph_(graph), common_(common), machine_(machine), cache_(zone()) {}

  // 创建一个Int32Constant node
  Node* Int32Constant(int32_t value);
  ...
  // Global cache of the dead node.
  Node* Dead() {
    return Dead_ ? Dead_ : Dead_ = graph_->NewNode(common_->Dead());
  }

  CommonOperatorBuilder* common() const { return common_; }
  MachineOperatorBuilder* machine() const { return machine_; }
  Graph* graph() const { return graph_; }
  Zone* zone() const { return graph()->zone(); }

 protected:
  Graph* graph_;
  CommonOperatorBuilder* common_;
  MachineOperatorBuilder* machine_;
  CommonNodeCache cache_;
  Node* Dead_ = nullptr;
};
```
MachineGraph类中成员有graph_ , 同时增加了生成一些机器级的operator节点的成员函数,生成这些节点借助了Graph类中的NewNode函数
这些函数的实现如下:
```c++
Node* MachineGraph::Int32Constant(int32_t value) {
  Node** loc = cache_.FindInt32Constant(value);
  if (*loc == nullptr) {
    *loc = graph()->NewNode(common()->Int32Constant(value));
  }
  return *loc;
}
...

```

JSGraph类:
```c++
// 在Graph上实现Facade，使用特定于JS的概念增强graph，包括运算符的各种构建器，规范化的全局常量和各种辅助方法。
class V8_EXPORT_PRIVATE JSGraph : public MachineGraph {
 public:
  JSGraph(Isolate* isolate, Graph* graph, CommonOperatorBuilder* common,
          JSOperatorBuilder* javascript, SimplifiedOperatorBuilder* simplified,
          MachineOperatorBuilder* machine)
      : MachineGraph(graph, common, machine),
        isolate_(isolate),
        javascript_(javascript),
        simplified_(simplified) {
  }

  // CEntryStubs are cached depending on the result size and other flags.
  Node* CEntryStubConstant(int result_size,
                           SaveFPRegsMode save_doubles = kDontSaveFPRegs,
                           ArgvMode argv_mode = kArgvOnStack,
                           bool builtin_exit_frame = false);

  // Used for padding frames. (alias: the hole)
  Node* PaddingConstant() { return TheHoleConstant(); }

  // Used for stubs and runtime functions with no context. (alias: SMI zero)
  Node* NoContextConstant() { return ZeroConstant(); }

  // Creates a HeapConstant node, possibly canonicalized, and may access the
  // heap to inspect the object.
  Node* HeapConstant(Handle<HeapObject> value);

  // Creates a Constant node of the appropriate type for the given object.
  // Accesses the heap to inspect the object and determine whether one of the
  // canonicalized globals or a number constant should be returned.
  Node* Constant(Handle<Object> value);

  // Like above, but doesn't access the heap directly.
  Node* Constant(const ObjectRef& value);

  // Creates a NumberConstant node, usually canonicalized.
  Node* Constant(double value);

  // Creates a HeapConstant node for either true or false.
  Node* BooleanConstant(bool is_true) {
    return is_true ? TrueConstant() : FalseConstant();
  }

  Node* SmiConstant(int32_t immediate) {
    DCHECK(Smi::IsValid(immediate));
    return Constant(immediate);
  }

  JSOperatorBuilder* javascript() const { return javascript_; }
  SimplifiedOperatorBuilder* simplified() const { return simplified_; }
  Isolate* isolate() const { return isolate_; }
  Factory* factory() const { return isolate()->factory(); }

  // Adds all the cached nodes to the given list.
  void GetCachedNodes(NodeVector* nodes);

// Cached global nodes.
#define CACHED_GLOBAL_LIST(V)              \
  V(AllocateInYoungGenerationStubConstant) \
  V(AllocateInOldGenerationStubConstant)   \
  V(ArrayConstructorStubConstant)          \
  V(BigIntMapConstant)                     \
  V(BooleanMapConstant)                    \
  V(ToNumberBuiltinConstant)               \
  V(EmptyFixedArrayConstant)               \
  V(EmptyStringConstant)                   \
  V(FixedArrayMapConstant)                 \
  V(PropertyArrayMapConstant)              \
  V(FixedDoubleArrayMapConstant)           \
  V(HeapNumberMapConstant)                 \
  V(OptimizedOutConstant)                  \
  V(StaleRegisterConstant)                 \
  V(UndefinedConstant)                     \
  V(TheHoleConstant)                       \
  V(TrueConstant)                          \
  V(FalseConstant)                         \
  V(NullConstant)                          \
  V(ZeroConstant)                          \
  V(OneConstant)                           \
  V(NaNConstant)                           \
  V(MinusOneConstant)                      \
  V(EmptyStateValues)                      \
  V(SingleDeadTypedStateValues)

// Cached global node accessor methods.
#define DECLARE_GETTER(name) Node* name();
  CACHED_GLOBAL_LIST(DECLARE_GETTER)
#undef DECLARE_FIELD

 private:
  Isolate* isolate_;
  JSOperatorBuilder* javascript_;
  SimplifiedOperatorBuilder* simplified_;

#define CACHED_CENTRY_LIST(V) \
  V(CEntryStub1Constant)      \
  V(CEntryStub2Constant)      \
  V(CEntryStub3Constant)      \
  V(CEntryStub1WithBuiltinExitFrameConstant)

// Canonicalized global node fields.
#define DECLARE_FIELD(name) Node* name##_ = nullptr;
  CACHED_GLOBAL_LIST(DECLARE_FIELD)
  CACHED_CENTRY_LIST(DECLARE_FIELD)
#undef DECLARE_FIELD

  // Internal helper to canonicalize a number constant.
  Node* NumberConstant(double value);

};
```

JSGraph类的功能基本上和MachineGraph类差不多，都是用来生成该level的节点，js level的operator定义在js-operator.cc中

