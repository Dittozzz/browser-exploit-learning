为了方便阅读,这里使用了一大堆的宏来定义token:
```c++
/* 二元运算符 */
/* ADD and SUB are at the end since they are UnaryOp */
#define BINARY_OP_TOKEN_LIST(T, E) \
  E(T, BIT_OR, "|", 6)             \
  E(T, BIT_XOR, "^", 7)            \
  E(T, BIT_AND, "&", 8)            \
  E(T, SHL, "<<", 11)              \
  E(T, SAR, ">>", 11)              \
  E(T, SHR, ">>>", 11)             \
  E(T, MUL, "*", 13)               \
  E(T, DIV, "/", 13)               \
  E(T, MOD, "%", 13)               \
  E(T, EXP, "**", 14)              \
  E(T, ADD, "+", 12)               \
  E(T, SUB, "-", 12)   
#define EXPAND_BINOP_ASSIGN_TOKEN(T, name, string, precedence) \
  T(ASSIGN_##name, string "=", 2)

#define EXPAND_BINOP_TOKEN(T, name, string, precedence) \
  T(name, string, precedence)

#define TOKEN_LIST(T, K)   /*这里真正定义了token*/                  \
                                                                   \
  /* BEGIN PropertyOrCall */                                       \
  /* BEGIN Member */                                               \
  /* BEGIN Template */                                             \
  /* ES6 Template Literals */                                      \
  T(TEMPLATE_SPAN, nullptr, 0)                                     \
  T(TEMPLATE_TAIL, nullptr, 0)                                     \
  /* END Template */                                               \
                                                                   \
  /* Punctuators (ECMA-262, section 7.7, page 15). */              \
  /* BEGIN Property */                                             \
  T(PERIOD, ".", 0)                                                \
  T(LBRACK, "[", 0)                 
```

在后面的token类中:
```c++
class V8_EXPORT_PRIVATE Token {
 public:
  // All token values.
#define T(name, string, precedence) name,
  enum Value : uint8_t { TOKEN_LIST(T, T) NUM_TOKENS }; //这里使用`TOKEN_LIST`这个宏来定义枚举变量
#undef T
```
预处理后代码长这个样子:
```c++
# 1 "test.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "test.cpp"
# 10 "test.cpp"
namespace v8 {
namespace internal {
# 202 "test.cpp"
class V8_EXPORT_PRIVATE Token {
 public:

/*这里是他使用的token*/
  enum Value : uint8_t { 
  TEMPLATE_SPAN, TEMPLATE_TAIL, PERIOD, LBRACK, LPAREN, RPAREN, RBRACK, 
  LBRACE, COLON, ELLIPSIS, CONDITIONAL, SEMICOLON, RBRACE, EOS, ARROW, INIT, ASSIGN, ASSIGN_BIT_OR, 
  ASSIGN_BIT_XOR, ASSIGN_BIT_AND, ASSIGN_SHL, ASSIGN_SAR, ASSIGN_SHR, ASSIGN_MUL, ASSIGN_DIV, ASSIGN_MOD,
  ASSIGN_EXP, ASSIGN_ADD, ASSIGN_SUB, COMMA, OR, AND, BIT_OR, BIT_XOR, BIT_AND, SHL, SAR, SHR, MUL, DIV, 
  MOD, EXP, ADD, SUB, NOT, BIT_NOT, DELETE, TYPEOF, VOID, INC, DEC, EQ, EQ_STRICT, NE, NE_STRICT, LT, GT, 
  LTE, GTE, INSTANCEOF, IN, BREAK, CASE, CATCH, CONTINUE, DEBUGGER, DEFAULT, DO, ELSE, FINALLY, FOR, 
  FUNCTION, IF, NEW, RETURN, SWITCH, THROW, TRY, VAR, WHILE, WITH, THIS, NULL_LITERAL, TRUE_LITERAL, 
  FALSE_LITERAL, NUMBER, SMI, BIGINT, STRING, SUPER, IDENTIFIER, GET, SET, ASYNC, AWAIT, YIELD, LET, STATIC, FUTURE_STRICT_RESERVED_WORD, ESCAPED_STRICT_RESERVED_WORD, ENUM, CLASS, CONST, EXPORT, EXTENDS, IMPORT, PRIVATE_NAME, ILLEGAL, ESCAPED_KEYWORD, WHITESPACE, UNINITIALIZED, REGEXP_LITERAL, NUM_TOKENS };


  static const char* Name(Value token) {
    DCHECK_GT(NUM_TOKENS, token);
    return name_[token];
  }

  class IsKeywordBits : public BitField8<bool, 0, 1> {};
  class IsPropertyNameBits : public BitField8<bool, IsKeywordBits::kNext, 1> {};


  static bool IsKeyword(Value token) {
    return IsKeywordBits::decode(token_flags[token]);
  }

  static bool IsPropertyName(Value token) {
    return IsPropertyNameBits::decode(token_flags[token]);
  }

  V8_INLINE static bool IsValidIdentifier(Value token,
                                          LanguageMode language_mode,
                                          bool is_generator,
                                          bool disallow_await) {
    if (V8_LIKELY(IsInRange(token, IDENTIFIER, ASYNC))) return true;
    if (token == AWAIT) return !disallow_await;
    if (token == YIELD) return !is_generator && is_sloppy(language_mode);
    return IsStrictReservedWord(token) && is_sloppy(language_mode);
  }

  static bool IsCallable(Value token) {
    return IsInRange(token, SUPER, ESCAPED_STRICT_RESERVED_WORD);
  }

  static bool IsAutoSemicolon(Value token) {
    return IsInRange(token, SEMICOLON, EOS);
  }

  static bool IsAnyIdentifier(Value token) {
    return IsInRange(token, IDENTIFIER, ESCAPED_STRICT_RESERVED_WORD);
  }

  static bool IsStrictReservedWord(Value token) {
    return IsInRange(token, YIELD, ESCAPED_STRICT_RESERVED_WORD);
  }

  static bool IsLiteral(Value token) {
    return IsInRange(token, NULL_LITERAL, STRING);
  }

  static bool IsTemplate(Value token) {
    return IsInRange(token, TEMPLATE_SPAN, TEMPLATE_TAIL);
  }

  static bool IsMember(Value token) {
    return IsInRange(token, TEMPLATE_SPAN, LBRACK);
  }

  static bool IsProperty(Value token) {
    return IsInRange(token, PERIOD, LBRACK);
  }

  static bool IsPropertyOrCall(Value token) {
    return IsInRange(token, TEMPLATE_SPAN, LPAREN);
  }

  static bool IsArrowOrAssignmentOp(Value token) {
    return IsInRange(token, ARROW, ASSIGN_SUB);
  }

  static bool IsAssignmentOp(Value token) {
    return IsInRange(token, INIT, ASSIGN_SUB);
  }

  static bool IsBinaryOp(Value op) { return IsInRange(op, COMMA, SUB); }

  static bool IsCompareOp(Value op) { return IsInRange(op, EQ, IN); }

  static bool IsOrderedRelationalCompareOp(Value op) {
    return IsInRange(op, LT, GTE);
  }

  static bool IsEqualityOp(Value op) { return IsInRange(op, EQ, EQ_STRICT); }

  static Value BinaryOpForAssignment(Value op) {
    DCHECK(IsInRange(op, ASSIGN_BIT_OR, ASSIGN_SUB));
    Value result = static_cast<Value>(op - ASSIGN_BIT_OR + BIT_OR);
    DCHECK(IsBinaryOp(result));
    return result;
  }

  static bool IsBitOp(Value op) {
    return IsInRange(op, BIT_OR, SHR) || op == BIT_NOT;
  }

  static bool IsUnaryOp(Value op) { return IsInRange(op, ADD, VOID); }
  static bool IsCountOp(Value op) { return IsInRange(op, INC, DEC); }
  static bool IsUnaryOrCountOp(Value op) { return IsInRange(op, ADD, DEC); }
  static bool IsShiftOp(Value op) { return IsInRange(op, SHL, SHR); }




  static const char* String(Value token) {
    DCHECK_GT(NUM_TOKENS, token);
    return string_[token];
  }

  static uint8_t StringLength(Value token) {
    DCHECK_GT(NUM_TOKENS, token);
    return string_length_[token];
  }



  static int Precedence(Value token, bool accept_IN) {
    DCHECK_GT(NUM_TOKENS, token);
    return precedence_[accept_IN][token];
  }

 private:
  static const char* const name_[NUM_TOKENS];
  static const char* const string_[NUM_TOKENS];
  static const uint8_t string_length_[NUM_TOKENS];
  static const int8_t precedence_[2][NUM_TOKENS];
  static const uint8_t token_flags[NUM_TOKENS];
};

}
}
```
token.cc这里进行Token类中静态变量的初始化:
```c++
namespace v8 {
namespace internal {

#define T(name, string, precedence) #name, //换成name，即是enum中的值
const char* const Token::name_[NUM_TOKENS] = {TOKEN_LIST(T, T)};
#undef T


#define T(name, string, precedence) string, //换成对应的c风格字符串
const char* const Token::string_[NUM_TOKENS] = {TOKEN_LIST(T, T)};
#undef T

constexpr uint8_t length(const char* str) {
  return str ? static_cast<uint8_t>(strlen(str)) : 0;
}
#define T(name, string, precedence) length(string),
const uint8_t Token::string_length_[NUM_TOKENS] = {TOKEN_LIST(T, T)};
#undef T

#define T1(name, string, precedence) \
  ((Token::name == Token::IN) ? 0 : precedence),
#define T2(name, string, precedence) precedence,
// precedence_[0] for accept_IN == false, precedence_[1] for accept_IN = true.
const int8_t Token::precedence_[2][NUM_TOKENS] = {{TOKEN_LIST(T1, T1)},
                                                  {TOKEN_LIST(T2, T2)}};
#undef T2
#undef T1

#define KT(a, b, c) IsPropertyNameBits::encode(Token::IsAnyIdentifier(a)),
#define KK(a, b, c) \
  IsKeywordBits::encode(true) | IsPropertyNameBits::encode(true),
const uint8_t Token::token_flags[] = {TOKEN_LIST(KT, KK)};
#undef KT
#undef KK
```
